### 1) 값 입력 받기 (1번)
* Node.js로 문제 푸는법   

```
const readline = require("readline");   // require을 통해 readline 모듈을 받아온다

const rl = readline.createInterface({   // createInterface를 통해 인터페이스 객체 생성
    input: process.stdin,
    output: process.stdout,
});

rl.on("line", (line) => { 
      // 한 줄씩 입력받은 후 실행할 코드
      // 입력된 값은 line에 저장된다.

      console.log(line);         // : 줄바꿈이 된다
      // process.stdout.write(line) : 줄바꿈이 없어짐

      rl.close(); // close가 없으면 입력을 무한히 받는다.
  });
  
  rl.on('close', () => {
    // 입력이 끝난 후 실행할 코드
  })
```
<br>

* 다른 호출 방법

   * 장점: 특정 모듈만 불러올 수 있다   

   * 호이스팅: 문서 어디서 선언하든 맨 위로 불러오는 효과가 있음   

```
import readline from "readline/createInterface"
```

<br>
<hr>

### 2) 엘리스 토끼의 연금술
* 문자 ```금```, ```은```, ```동```가 무작위로 뒤섞여 주어질 때, ```은```, ```동```을 모두 ```금```으로 바꾸시오   

__풀이1 >__: 문자열로 풀기
```
function solution(jewel) {
    const arr = jewel.split(" ");
    let str = "";

    for (let i=0; i < arr.length; i++) {
        if (arr[i] !== "금") {
            str += "금 "
        } else {
            str += "금 "
        }
    }
    return str.slice(0, -1);    // 맨 끝 공백 제거
}
```
<br>
<br>

__풀이2 >__: 배열 값 변경
* __```배열.join(" ")```__: 배열 값들 사이에 공백 추가
```
function solution(jewel) {
    const arr = jewel.split(" ");

    for (let i=0; i < arr.length; i++) {
        if (arr[i] === "은" || arr[i] === "동") {
            arr[i] = "금";
        }
    }
    return arr.join(" ");
}
```
<br>
<br>

__풀이3 >__: ★ __forEach문__ ★   
* for문보다 성능에 있어 더 뛰어나다

   * 단, forEach 내에서 arr 값을 수정할 수 없다   
   
```
function solution(jewel) {
    const arr = jewel.split(" ");

    let newArr = [];

    arr.forEach((item) => {
        if (item === "은" || item === "동") {
            newArr.push("금");
        } else {
            newArr.push("금");
        }
    });
    return newArr.join(" ");
}
```
<br>
<br>

__풀이4 >__: map
```
function solution(jewel) {
    let arr = jewel.split(" ");

    arr = arr.map(() => "금");    // map으로 배열 값들을 불러옴

    return arr.join(" ");
}
```
<br>

### 2-1) ★ map ★
* 기존의 배열은 그대로 두고, 배열 요소들을 뽑아와 새로운 배열 생성

__Ex>__
```
const arr = [1, 2, 3];

let mapArr = arr.map((item) => item ** 3);
```
```
console.log(mapArr);   // [1, 8, 27]
```

<br>

### 2-2) ★ filter ★
* __특정 조건에 맞는__ 배열의 요소들을 뽑아와 새로운 배열 생성

__Ex1>__
```
  let x = [1, 2, 3, 4, 5, 6, 7]
  let y;
  y = x.filter(x => x > 4);        // [5, 6, 7]
```
<br>

__Ex2>__
```
  const arr = ["월요일", "화요일", "수요일", "목요일", "금요일"];
  
  let filterArr = arr.filter((item, idx) => idx % 2 !== 0);    // 인덱스 번호 = idx
```
```
  console.log(filterArr);   // ['화요일', '목요일']
```

<br>
<hr>

### 3) 탐사선의 메시지 (3번)
* 배열 data에서 각 라인에 해당하는 key 값을 불러온다

* 첫 번째 라인에 ```xxxxxxxx``` 값을 받을 경우, ```복구실패```라는 문자를 출력

* ```xxxxxxxx```는 이전 라인에 있는 데이터의 key 값을 불러온다

__입력 예시 >__
```
11110010
00000111
00100001
01011000
xxxxxxxx
01001011
01111011
01000011
```
<br>

__풀이1 >__
* __```배열.join("\n")```__: 줄바꿈   

```
function solution(message) {
    let arr = message.split("\n");

    if (arr[0] === "xxxxxxxx") { 
        return "복구실패";
    }

    for (let i = 1; i < message.length; i++) {
        if (arr[i] === "xxxxxxxx") {
            arr[i] = data[arr[i - 1]];
        }
    }

    return console.log(arr.join("\n"));    // 줄바꿈
}
```

<br>

__풀이2 >__
```

```
